# -*- coding: utf-8 -*-
"""
Created on Fri Jul 26 20:13:27 2013

@author: Tommy Löfstedt
@email: tommy.loefstedt@cea.fr
"""

__all__ = ['load']

import numpy as np
import structured.utils as utils
import structured.algorithms as algorithms


def load(l, k, gamma, density, snr, M, e, shape):
    """Returns data generated such that we know the exact solution.

    The data generated by this function is fit to the Elastic net + Total
    variation function, i.e.:

        f(b) = (1 / 2).|Xb - y|² + l.|b|_1 + ((1 - l) / 2).|b|² + g.TV(b),

    where |.|_1 is the L1 norm, |.|² is the squared L2 norm and TV is the
    total variation penalty in 2 dimensions.

    Parameters
    ----------
    l : The L1 regularisation parameter.

    k : The L2 regularisation parameter.

    gamma : The total variation regularisation parameter.

    density : The density of the returned regression vector (fraction of
            non-zero elements). Must be in (0, 1]. This may be approximate
            if no exact factors exist. E.g. if shape=(11,11) and
            density=0.2, then the closest density we actually get is 0.2066.

    snr : Signal to noise ratio between model and residual.

    M : The matrix to use when building data. This matrix carries the desired
            distribution of the generated data. The generated data will be a
            column-scaled version of this matrix.

    e : The error vector e = Xb - y. This vector carries the desired
            distribution of the residual. This vector must have unit 2-norm.

    shape : A 2-list or -tuple with the shape (rows-by-columns) of the
            2D-structure.

    Returns
    -------
    X : The generated X matrix.

    y : The generated y vector.

    beta : The generated regression vector.
    """
    seed = np.random.randint(2147483648)

    low = 0.0
    high = 1.0
    for i in xrange(30):
#        print "low:", low, "high:", high
        np.random.seed(seed)
        X, y, beta = _generate(l, k, gamma, density, high, M, e, shape)
        val = np.sqrt(np.sum(np.dot(X, beta) ** 2.0) / np.sum(e ** 2.0))
        if val > snr:
            break
        else:
            low = high
            high = high * 2.0

    def f(x):
        np.random.seed(seed)
        X, y, beta = _generate(l, k, gamma, density, x, M, e, shape)
        return np.sqrt(np.sum(np.dot(X, beta) ** 2.0) / np.sum(e ** 2.0)) - snr

    bm = algorithms.BisectionMethod(max_iter=20)
    bm.run(utils.AnonymousClass(f=f), low, high)

    np.random.seed(seed)
    X, y, beta = _generate(l, k, gamma, density, bm.x, M, e, shape)
    print "snr = %.5f = %.5f = |X.b| / |e| = %.5f / %.5f" \
            % (snr, np.linalg.norm(np.dot(X, beta) / np.linalg.norm(e)),
               np.linalg.norm(np.dot(X, beta)), np.linalg.norm(e))

    return X, y, beta
#    return _generate(l, k, gamma, density, snr, M, e, shape)


def _generate(l, k, gamma, density, snr, M, e, shape):

    l = float(l)
    k = float(k)
    gamma = float(gamma)
    density = float(density)
    snr = float(snr)

    p = M.shape[1]
    px = shape[1]
    py = shape[0]
    s = np.sqrt(density * p / (px * py))
    part = s * s * px * py / p
#    ps = int(round(p * density))
    pys = int(round(py * s))
    pxs = int(round(px * s))
    # Search for better approximation of px and py
    best_x = 0
    best_y = 0
    best = float("inf")
    for i in xrange(2):
        for j in xrange(2):
            diff = abs(((pys + i) * (pxs + j) / float(p)) - part)
            if diff < best:
                best = diff
                best_x = j
                best_y = i
    pys += best_y
    pxs += best_x

    sqrt2 = np.sqrt(2.0)

#    print abs((pys * pxs / float(p)) - part)
#    print pys
#    print pxs

    e = e / np.sqrt(np.sum(e ** 2.0))  # Don't trust the user ;-)

    b = np.dot(M.T, e)
    # TODO: This is suboptimal. Not all of the most correlated variables
    # will be in the positive quadrant.
    ind = np.flipud(np.argsort(np.abs(b), axis=0))
    b = b[ind[:, 0]]
    #    sign_b = np.sign(b)
    #    abs_b = np.abs(b)
    M = M[:, ind[:, 0]]

    beta = np.zeros((py, px))
    for i in xrange(py):
        for j in xrange(px):
            if i >= pys or j >= pxs:
                beta[i, j] = 0.0
            else:
                beta[i, j] = U(0, 1) * snr / np.sqrt(pys * pxs)
    beta = np.fliplr(np.sort(np.flipud(np.sort(beta, axis=0)), axis=1))

    X = np.zeros(M.shape)
    a = np.zeros((p, 1))

#    np.set_printoptions(threshold=100000)
    Mat = np.zeros(shape)

    # Case 1: Top-left corner
    # -----------------------
    # [00][0+][  ](  )(  )(  )
    # [+0][  ][  ](  )(  )(  )
    # [  ][  ][  ](  )(  )(  )
    # (  )(  )(  )(  )(  )(  )
    # (  )(  )(  )(  )(  )(  )
    # (  )(  )(  )(  )(  )(  )
    i, j = 0, 0
    k = i * px + j
    print "(", i, j, ") == ", k
    Mte = b[k, 0]
    grad = (2.0 * beta[i, j] - (beta[i + 1, j] + beta[i, j + 1])) \
            / np.sqrt((beta[i + 1, j] - beta[i, j]) ** 2.0 \
                    + (beta[i, j + 1] - beta[i, j]) ** 2.0)
    a[k, 0] = (-k * beta[i, j] - l - gamma * grad) / Mte
    X[:, k] = M[:, k] * a[k, 0]

    Mat[i, j] = 1
    print Mat

    # Case 2a: Top row on positive side.
    # ---------------------------------
    # [0-][00][0+](  )(  )(  )    [  ][0-][00](0+)(  )(  )
    # [+-][+0][  ](  )(  )(  )    [  ][+-][+0](  )(  )(  )
    # [  ][  ][  ](  )(  )(  )    [  ][  ][  ](  )(  )(  )
    # (  )(  )(  )(  )(  )(  )    (  )(  )(  )(  )(  )(  )
    # (  )(  )(  )(  )(  )(  )    (  )(  )(  )(  )(  )(  )
    # (  )(  )(  )(  )(  )(  )    (  )(  )(  )(  )(  )(  )
    i = 0
    for j in xrange(1, pxs):
        k = i * px + j
        print "(", i, j, ") == ", k
        Mte = b[k, 0]
        grad = (2.0 * beta[i, j] - (beta[i + 1, j] + beta[i, j + 1])) \
                 / np.sqrt((beta[i + 1, j] - beta[i, j]) ** 2.0 \
                         + (beta[i, j + 1] - beta[i, j]) ** 2.0) \
             + (beta[i, j] - beta[i, j - 1]) \
                 / np.sqrt((beta[i + 1, j - 1] - beta[i, j - 1]) ** 2.0 \
                         + (beta[i, j] - beta[i, j - 1]) ** 2.0)
        a[k, 0] = (-k * beta[i, j] - l - gamma * grad) / Mte
        X[:, k] = M[:, k] * a[k, 0]

        Mat[i, j] = 2
    print Mat

    # Case 3: First zero on top row.
    # -----------------------
    # [  ][  ][0-](00)(0+)(  )
    # [  ][  ][+-](+0)(  )(  )
    # [  ][  ][  ](  )(  )(  )
    # (  )(  )(  )(  )(  )(  )
    # (  )(  )(  )(  )(  )(  )
    # (  )(  )(  )(  )(  )(  )
    i = 0
    j = pxs
    k = i * px + j
    print "(", i, j, ") == ", k
    Mte = b[k, 0]
    subgrad = sqrt2 * U(-1, 1)
    grad = (beta[i, j] - beta[i, j - 1]) \
             / np.sqrt((beta[i + 1, j - 1] - beta[i, j - 1]) ** 2.0 \
                     + (beta[i, j] - beta[i, j - 1]) ** 2.0)
    a[k, 0] = (-k * beta[i, j] - l * U(-1, 1) - gamma * (subgrad + grad)) \
            / Mte
    X[:, k] = M[:, k] * a[k, 0]

    Mat[i, j] = 3
    print Mat

    # Case 4a: Top row on negative side.
    # -----------------------
    # [  ][  ][  ](0-)(00)(0+)
    # [  ][  ][  ](+-)(+0)(  )
    # [  ][  ][  ](  )(  )(  )
    # (  )(  )(  )(  )(  )(  )
    # (  )(  )(  )(  )(  )(  )
    # (  )(  )(  )(  )(  )(  )
    i = 0
    for j in xrange(pxs + 1, px - 1):
        k = i * px + j
        print "(", i, j, ") == ", k
        Mte = b[k, 0]
        subgrad = sqrt2 * U(-1, 1) + U(-1, 1)
        a[k, 0] = (-k * beta[i, j] - l * U(-1, 1) - gamma * subgrad) / Mte
        X[:, k] = M[:, k] * a[k, 0]

        Mat[i, j] = 4
    print Mat

    # Case 5a: Top right corner.
    # -------------------------
    # [  ][  ][  ](  )(0-)(00)
    # [  ][  ][  ](  )(+-)(+0)
    # [  ][  ][  ](  )(  )(  )
    # (  )(  )(  )(  )(  )(  )
    # (  )(  )(  )(  )(  )(  )
    # (  )(  )(  )(  )(  )(  )
    i = 0
    j = px - 1
    k = i * px + j
    print "(", i, j, ") == ", k
    Mte = b[k, 0]
    subgrad = U(-1, 1) + U(-1, 1)
    a[k, 0] = (-k * beta[i, j] - l * U(-1, 1) - gamma * subgrad) / Mte
    X[:, k] = M[:, k] * a[k, 0]

    Mat[i, j] = 5
    print Mat

    # Case 2b: Left-most column on positive side.
    # ------------------------------------------
    # [-0][-+][  ](  )(  )(  )
    # [00][0+][  ](  )(  )(  )
    # [+0][  ][  ](  )(  )(  )
    # (  )(  )(  )(  )(  )(  )
    # (  )(  )(  )(  )(  )(  )
    # (  )(  )(  )(  )(  )(  )
    #
    # [  ][  ][  ](  )(  )(  )
    # [-0][-+][  ](  )(  )(  )
    # [00][0+][  ](  )(  )(  )
    # (+0)(  )(  )(  )(  )(  )
    # (  )(  )(  )(  )(  )(  )
    # (  )(  )(  )(  )(  )(  )
    j = 0
    for i in xrange(1, pys):
        k = i * px + j
        print "(", i, j, ") == ", k
        Mte = b[k, 0]
        grad = (2.0 * beta[i, j] - (beta[i + 1, j] + beta[i, j + 1])) \
                 / np.sqrt((beta[i + 1, j] - beta[i, j]) ** 2.0 \
                         + (beta[i, j + 1] - beta[i, j]) ** 2.0) \
             + (beta[i, j] - beta[i - 1, j]) \
                 / np.sqrt((beta[i, j] - beta[i - 1, j]) ** 2.0 \
                         + (beta[i - 1, j + 1] - beta[i - 1, j]) ** 2.0)
        a[k, 0] = (-k * beta[i, j] - l - gamma * grad) / Mte
        X[:, k] = M[:, k] * a[k, 0]

        Mat[i, j] = 2
    print Mat

    # Case 3b: First zero in left-most column.
    # ---------------------------------------
    # [  ][  ][  ](  )(  )(  )
    # [  ][  ][  ](  )(  )(  )
    # [-0][-+][  ](  )(  )(  )
    # (00)(0+)(  )(  )(  )(  )
    # (+0)(  )(  )(  )(  )(  )
    # (  )(  )(  )(  )(  )(  )
    i = pys
    j = 0
    k = i * px + j
    print "(", i, j, ") == ", k
    Mte = b[k, 0]
    subgrad = sqrt2 * U(-1, 1)
    grad = (beta[i, j] - beta[i - 1, j]) \
             / np.sqrt((beta[i, j] - beta[i - 1, j]) ** 2.0 \
                     + (beta[i - 1, j + 1] - beta[i - 1, j]) ** 2.0)
    a[k, 0] = (-k * beta[i, j] - l * U(-1, 1) - gamma * (subgrad + grad)) \
            / Mte
    X[:, k] = M[:, k] * a[k, 0]

    Mat[i, j] = 3
    print Mat

    # Case 4b: Left-most column on negative side.
    # ------------------------------------------
    # [  ][  ][  ](  )(  )(  )
    # [  ][  ][  ](  )(  )(  )
    # [  ][  ][  ](  )(  )(  )
    # (-0)(-+)(  )(  )(  )(  )
    # (00)(0+)(  )(  )(  )(  )
    # (+0)(  )(  )(  )(  )(  )
    j = 0
    for i in xrange(pys + 1, px - 1):
        k = i * px + j
        print "(", i, j, ") == ", k
        Mte = b[k, 0]
        subgrad = sqrt2 * U(-1, 1) + U(-1, 1)
        a[k, 0] = (-k * beta[i, j] - l * U(-1, 1) - gamma * subgrad) / Mte
        X[:, k] = M[:, k] * a[k, 0]

        Mat[i, j] = 4
    print Mat

    # Case 5b: Bottom-left corner.
    # ---------------------------
    # [  ][  ][  ](  )(  )(  )
    # [  ][  ][  ](  )(  )(  )
    # [  ][  ][  ](  )(  )(  )
    # (  )(  )(  )(  )(  )(  )
    # (-0)(-+)(  )(  )(  )(  )
    # (00)(0+)(  )(  )(  )(  )
    i = py - 1
    j = 0
    k = i * px + j
    print "(", i, j, ") == ", k
    Mte = b[k, 0]
    subgrad = U(-1, 1) + U(-1, 1)
    a[k, 0] = (-k * beta[i, j] - l * U(-1, 1) - gamma * subgrad) / Mte
    X[:, k] = M[:, k] * a[k, 0]

    Mat[i, j] = 5
    print Mat

    # Case 6: Inside positive part.
    # ---------------------------
    # [  ][-0][-+](  )(  )(  )
    # [0-][00][0+](  )(  )(  )
    # [+-][+0][  ](  )(  )(  )
    # (  )(  )(  )(  )(  )(  )
    # (  )(  )(  )(  )(  )(  )
    # (  )(  )(  )(  )(  )(  )
    for i in xrange(1, pys):
        for j in xrange(1, pxs):
            k = i * px + j
            print "(", i, j, ") == ", k
            Mte = b[k, 0]
            grad = (2.0 * beta[i, j] - (beta[i + 1, j] + beta[i, j + 1])) \
                     / np.sqrt((beta[i + 1, j] - beta[i, j]) ** 2.0 \
                             + (beta[i, j + 1] - beta[i, j]) ** 2.0) \
                 + (beta[i, j] - beta[i - 1, j]) \
                     / np.sqrt((beta[i, j] - beta[i - 1, j]) ** 2.0 \
                             + (beta[i - 1, j + 1] - beta[i - 1, j]) ** 2.0) \
                 + (beta[i, j] - beta[i, j - 1]) \
                     / np.sqrt((beta[i + 1, j - 1] - beta[i, j - 1]) ** 2.0 \
                             + (beta[i, j] - beta[i, j - 1]) ** 2.0)
            a[k, 0] = (-k * beta[i, j] - l - gamma * grad) / Mte
            X[:, k] = M[:, k] * a[k, 0]

            Mat[i, j] = 6
    print Mat

    # Case 7a: First zero to the right of the positive part.
    # ---------------------------
    # [  ][  ][  ](-0)(-+)(  )
    # [  ][  ][0-](00)(0+)(  )
    # [  ][  ][+-](+0)(  )(  )
    # (  )(  )(  )(  )(  )(  )
    # (  )(  )(  )(  )(  )(  )
    # (  )(  )(  )(  )(  )(  )
    #
    # [  ][  ][  ](  )(  )(  )
    # [  ][  ][  ](-0)(-+)(  )
    # [  ][  ][0-](00)(0+)(  )
    # [  ][  ][+-](+0)(  )(  )
    # (  )(  )(  )(  )(  )(  )
    # (  )(  )(  )(  )(  )(  )
    j = pxs
    for i in xrange(1, pys):
        k = i * px + j
        print "(", i, j, ") == ", k
        Mte = b[k, 0]
        subgrad = sqrt2 * U(-1, 1) + U(-1, 1)
        grad = (beta[i, j] - beta[i, j - 1]) \
                 / np.sqrt((beta[i + 1, j - 1] - beta[i, j - 1]) ** 2.0 \
                         + (beta[i, j] - beta[i, j - 1]) ** 2.0)
        a[k, 0] = (-k * beta[i, j] - l * U(-1, 1) \
                   - gamma * (subgrad + grad)) / Mte
        X[:, k] = M[:, k] * a[k, 0]

        Mat[i, j] = 7
    print Mat

    # Case 7b: First zero below center of positive part.
    # -------------------------------------------------
    # [  ][  ][  ][  ](  )(  )    [  ][  ][  ][  ][  ](  )
    # [  ][  ][  ][  ](  )(  )    [  ][  ][  ][  ][  ](  )
    # [  ][-0][-+][  ](  )(  )    [  ][  ][-0][-+][  ](  )
    # (0-)(00)(0+)(  )(  )(  )    (  )(0-)(00)(0+)(  )(  )
    # (+-)(+0)(  )(  )(  )(  )    (  )(+-)(+0)(  )(  )(  )
    # (  )(  )(  )(  )(  )(  )    (  )(  )(  )(  )(  )(  )
    i = pys
    for j in xrange(1, pxs):
        k = i * px + j
        print "(", i, j, ") == ", k
        Mte = b[k, 0]
        subgrad = sqrt2 * U(-1, 1) + U(-1, 1)
        grad = (beta[i, j] - beta[i - 1, j]) \
                 / np.sqrt((beta[i, j] - beta[i - 1, j]) ** 2.0 \
                         + (beta[i - 1, j + 1] - beta[i - 1, j]) ** 2.0)
        a[k, 0] = (-k * beta[i, j] - l * U(-1, 1) \
                   - gamma * (subgrad + grad)) / Mte
        X[:, k] = M[:, k] * a[k, 0]

        Mat[i, j] = 7
    print Mat

    # Case 8a: Inside zero part.
    # -------------------------
    # [  ][  ][  ](  )(-0)(  )
    # [  ][  ][  ](0-)(00)(0+)
    # [  ][  ][  ](  )(+0)(  )
    # (  )(  )(  )(  )(  )(  )
    # (  )(  )(  )(  )(  )(  )
    # (  )(  )(  )(  )(  )(  )
    #
    # [  ][  ][  ](  )(  )(  )
    # [  ][  ][  ](  )(-0)(  )
    # [  ][  ][  ](0-)(00)(0+)
    # (  )(  )(  )(  )(+0)(  )
    # (  )(  )(  )(  )(  )(  )
    # (  )(  )(  )(  )(  )(  )
    for i in xrange(1, pys):
        for j in xrange(pxs + 1, px - 1):
            k = i * px + j
            print "(", i, j, ") == ", k
            Mte = b[k, 0]
            subgrad = sqrt2 * U(-1, 1) + U(-1, 1) + U(-1, 1)
            a[k, 0] = (-k * beta[i, j] - l * U(-1, 1) - gamma * subgrad) \
                    / Mte
            X[:, k] = M[:, k] * a[k, 0]

            Mat[i, j] = 8
    print Mat

    # Case 9a: Right-edge zero-border.
    # -------------------------
    # [  ][  ][  ][  ][  ](-0)
    # [  ][  ][  ][  ][0-](00)
    # [  ][  ][  ][  ][  ](+0)
    # (  )(  )(  )(  )(  )(  )
    # (  )(  )(  )(  )(  )(  )
    # (  )(  )(  )(  )(  )(  )
    #
    # [  ][  ][  ](  )(  )(  )
    # [  ][  ][  ](  )(  )(-0)
    # [  ][  ][  ](  )(0-)(00)
    # (  )(  )(  )(  )(  )(+0)
    # (  )(  )(  )(  )(  )(  )
    # (  )(  )(  )(  )(  )(  )
    #
    # [  ][  ][  ](  )(  )(  )
    # [  ][  ][  ](  )(  )(  )
    # [  ][  ][  ](  )(  )(-0)
    # (  )(  )(  )(  )(0-)(00)
    # (  )(  )(  )(  )(  )(+0)
    # (  )(  )(  )(  )(  )(  )
    #
    # [  ][  ][  ](  )(  )(  )
    # [  ][  ][  ](  )(  )(  )
    # [  ][  ][  ](  )(  )(  )
    # [  ][  ][  ](  )(  )(-0)
    # (  )(  )(  )(  )(0-)(00)
    # (  )(  )(  )(  )(  )(+0)
    j = px - 1
    for i in xrange(1, py - 1):
        k = i * px + j
        print "(", i, j, ") == ", k
        Mte = b[k, 0]
        subgrad = U(-1, 1) + U(-1, 1) + U(-1, 1)
        a[k, 0] = (-k * beta[i, j] - l * U(-1, 1) - gamma * subgrad) / Mte
        X[:, k] = M[:, k] * a[k, 0]

        Mat[i, j] = 9
    print Mat

#    # First half done!! \o/ ;-)

    # Case 8c: Inside zero part below positive part.
    # ---------------------------------------------
    # [  ][  ][  ](  )(  )(  )    [  ][  ][  ](  )(  )(  )
    # [  ][  ][  ](  )(  )(  )    [  ][  ][  ](  )(  )(  )
    # [  ][  ][  ](  )(  )(  )    [  ][  ][  ](  )(  )(  )
    # (  )(-0)(-+)(  )(  )(  )    (  )(  )(-0)(-+)(  )(  )
    # (0-)(00)(0+)(  )(  )(  )    (  )(0-)(00)(0+)(  )(  )
    # (+-)(+0)(  )(  )(  )(  )    (  )(+-)(+0)(  )(  )(  )
    for i in xrange(pys + 1, py - 1):
        for j in xrange(1, pxs):
            k = i * px + j
            print "(", i, j, ") == ", k
            Mte = b[k, 0]
            subgrad = sqrt2 * U(-1, 1) + U(-1, 1) + U(-1, 1)
            a[k, 0] = (-k * beta[i, j] - l * U(-1, 1) - gamma * subgrad) \
                    / Mte
            X[:, k] = M[:, k] * a[k, 0]

            Mat[i, j] = 8
    print Mat

    # Case 9b: Bottom-edge zero-border.
    # --------------------------------
    # [  ][  ][  ](  )(  )(  )    [  ][  ][  ](  )(  )(  )
    # [  ][  ][  ](  )(  )(  )    [  ][  ][  ](  )(  )(  )
    # [  ][  ][  ](  )(  )(  )    [  ][  ][  ](  )(  )(  )
    # (  )(  )(  )(  )(  )(  )    (  )(  )(  )(  )(  )(  )
    # (  )(-0)(-+)(  )(  )(  )    (  )(  )(-0)(-+)(  )(  )
    # (0-)(00)(0+)(  )(  )(  )    (  )(0-)(00)(0+)(  )(  )
    #
    # [  ][  ][  ](  )(  )(  )    [  ][  ][  ](  )(  )(  )
    # [  ][  ][  ](  )(  )(  )    [  ][  ][  ](  )(  )(  )
    # [  ][  ][  ](  )(  )(  )    [  ][  ][  ](  )(  )(  )
    # (  )(  )(  )(  )(  )(  )    (  )(  )(  )(  )(  )(  )
    # (  )(  )(  )(-0)(-+)(  )    (  )(  )(  )(  )(-0)(-+)
    # (  )(  )(0-)(00)(0+)(  )    (  )(  )(  )(0-)(00)(0+)
    i = py - 1
    for j in xrange(1, px - 1):
        k = i * px + j
        print "(", i, j, ") == ", k
        Mte = b[k, 0]
        subgrad = U(-1, 1) + U(-1, 1) + U(-1, 1)
        a[k, 0] = (-k * beta[i, j] - l * U(-1, 1) - gamma * subgrad) / Mte
        X[:, k] = M[:, k] * a[k, 0]

        Mat[i, j] = 9
    print Mat

    # Case 8b: Inside zero part.
    # -------------------------
    # [  ][  ][  ](  )(  )(  )
    # [  ][  ][  ](  )(  )(  )
    # [  ][  ][  ](-0)(-+)(  )
    # (  )(  )(0-)(00)(0+)(  )
    # (  )(  )(+-)(+0)(  )(  )
    # (  )(  )(  )(  )(  )(  )
    #
    # [  ][  ][  ][  ](  )(  )
    # [  ][  ][  ][  ](  )(  )
    # [  ][  ][  ][  ](-0)(-+)
    # (  )(  )(  )(0-)(00)(0+)
    # (  )(  )(  )(+-)(+0)(  )
    # (  )(  )(  )(  )(  )(  )
    #
    # [  ][  ][  ](  )(  )(  )
    # [  ][  ][  ](  )(  )(  )
    # [  ][  ][  ](  )(  )(  )
    # (  )(  )(  )(-0)(-+)(  )
    # (  )(  )(0-)(00)(0+)(  )
    # (  )(  )(+-)(+0)(  )(  )
    #
    # [  ][  ][  ](  )(  )(  )
    # [  ][  ][  ](  )(  )(  )
    # [  ][  ][  ](  )(  )(  )
    # (  )(  )(  )(  )(-0)(-+)
    # (  )(  )(  )(0-)(00)(0+)
    # (  )(  )(  )(+-)(+0)(  )
    for i in xrange(pys, py - 1):
        for j in xrange(pxs, px - 1):
            k = i * px + j
            print "(", i, j, ") == ", k
            Mte = b[k, 0]
            subgrad = sqrt2 * U(-1, 1) + U(-1, 1) + U(-1, 1)
            a[k, 0] = (-k * beta[i, j] - l * U(-1, 1) - gamma * subgrad) \
                    / Mte
            X[:, k] = M[:, k] * a[k, 0]

            Mat[i, j] = 8
    print Mat

    # Case 5c: Bottom-right corner.
    # ----------------------------
    # [  ][  ][  ](  )(  )(  )
    # [  ][  ][  ](  )(  )(  )
    # [  ][  ][  ](  )(  )(  )
    # (  )(  )(  )(  )(  )(  )
    # (  )(  )(  )(  )(  )(-0)
    # (  )(  )(  )(  )(0-)(00)
    i = py - 1
    j = px - 1
    k = i * px + j
    print "(", i, j, ") == ", k
    Mte = b[k, 0]
    subgrad = U(-1, 1) + U(-1, 1)
    a[k, 0] = (-k * beta[i, j] - l * U(-1, 1) - gamma * subgrad) / Mte
    X[:, k] = M[:, k] * a[k, 0]

    Mat[i, j] = 5
    print Mat

    beta = np.reshape(beta, (p, 1))
    y = np.dot(X, beta) - e

#    Y = np.zeros(X.shape)
#    for i in range(X.shape[1]):
#        Y[:, ind[i, 0]] = M[:, i]
#
#    return Y, y, beta
    return X, y, beta


def U(a, b):
    t = max(a, b)
    a = float(min(a, b))
    b = float(t)
    return (np.random.rand() * (b - a)) + a