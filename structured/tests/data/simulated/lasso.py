# -*- coding: utf-8 -*-
"""
Created on Tue Jul 16 11:33:05 2013

@author: Tommy Löfstedt
@email: tommy.loefstedt@cea.fr
"""

__all__ = ['load']

import numpy as np
import structured.utils as utils
import structured.algorithms as algorithms


def load(l, density, snr, P, e):
    """Returns data generated such that we know the exact solution.

    The data generated by this function is fit to the Lasso function, i.e.:

        f(b) = (1 / 2).|Xb - y|² + l.|b|_1,

    where |.|² is the squared L2 norm, and |.|_1 is the L1 norm.

    Parameters
    ----------
    l : The L1 regularisation parameter.

    density : The density of the returned regression vector (fraction of
            non-zero elements). Must be in (0, 1].

    snr : Signal to noise ratio between model and residual.

    P : The matrix to use when building data. This matrix carries the desired
            distribution of the generated data. The generated data will be a
            scaled version of this matrix.

    e : The error vector e = Xb - y. This vector carries the desired
            distribution of the residual. This vector must have unit 2-norm.

    Returns
    -------
    X : The generated X matrix.

    y : The generated y vector.

    beta : The generated regression vector.
    """

    seed = np.random.randint(2147483648)

    low = 0.0
    high = 1.0
    for i in xrange(30):
        np.random.seed(seed)
        X, y, beta = _generate(l, density, high, P, e)
        val = np.sqrt(np.sum(np.dot(X, beta) ** 2.0) / np.sum(e ** 2.0))
        if val > snr:
            break
        else:
            low = high
            high = high * 2.0

    def f(x):
        np.random.seed(seed)
        X, y, beta = _generate(l, density, x, P, e)
        return np.sqrt(np.sum(np.dot(X, beta) ** 2.0) / np.sum(e ** 2.0)) - snr

    bm = algorithms.BisectionMethod(max_iter=20)
    bm.run(utils.AnonymousClass(f=f), low, high)

    np.random.seed(seed)
    X, y, beta = _generate(l, density, bm.x, P, e)

    return X, y, beta
#    return _generate(l, density, snr, P, e)


def _generate(l, density, snr, P, e):
    l = float(l)
    density = float(density)
    snr = float(snr)
#    n = P.shape[0]
    p = P.shape[1]
    ps = int(round(p * density))
    e = e / np.sqrt(np.sum(e ** 2.0))

#    b = np.dot(P.T, e)
#    ind = np.flipud(np.argsort(np.abs(b), axis=0))
#    b = b[ind[:, 0]]
#    sign_b = np.sign(b)
#    abs_b = np.abs(b)
#
##    a_plus = l / abs_b[:ps, [0]]
##
##    abs_b_zero = abs_b[ps:, [0]]  # |P'e|
##    ind = (abs_b_zero / l) <= 1.0  # |P'e| / l <= 1.0
##
##    a_zero = np.zeros((p - ps, 1))
##    a_zero[ind] = 1.0  # When |P'e| / l <= 1.0, alpha = 1
##    ind = np.logical_not(ind)
##    xi = (np.random.rand(p - ps, 1) - 0.5) * 2.0
##    a_zero[ind] = -l / abs_b_zero[ind]  # When |P'e| / l > 1.0, a = -l / |P'e|
###    a_zero[ind] = np.divide(-l * xi[ind], abs_b_zero[ind])
###    a_zero = np.multiply(a_zero, xi)
#
#    X = np.zeros(P.shape)
#    a = np.zeros((p, 1))
#    for i in xrange(p):
#        if i <= ps:
#            a[i, 0] = -l / abs_b[i, 0]
#        else:
#            if abs_b[i, 0] < 0.1:
#                a[i, 0] = 1.0
#            else:
#                a[i, 0] = -l * np.random.rand() / abs_b[i, 0]
#
##    a = np.vstack((a_plus, a_zero))
#
#    X = P * a.T
#
#    beta = np.zeros((p, 1))
#    xi = np.random.rand(ps, 1) * (snr / np.sqrt(ps))
#    beta[:ps, [0]] = np.multiply(xi, np.sign(np.dot(X.T, e)))  # sign_b[:ps, [0]])
#
#    y = np.dot(X, beta) + e

    b = np.dot(P.T, e)
    ind = np.flipud(np.argsort(np.abs(b), axis=0))
    b = b[ind[:, 0]]
#    sign_b = np.sign(b)
    abs_b = np.abs(b)
    P = P[:, ind[:, 0]]

    X = np.zeros(P.shape)
    a = np.zeros((p, 1))
    beta = np.zeros((p, 1))
    for i in xrange(p):
        if i < ps:
            a[i, 0] = l / abs_b[i, 0]
        else:
            if abs_b[i, 0] < 1.0:
                a[i, 0] = l
            else:
                a[i, 0] = l * np.random.rand() / abs_b[i, 0]

        X[:, i] = P[:, i] * a[i, 0]

    for i in xrange(p):
        if i >= ps:
            beta[i, 0] = 0
        else:
            xi = np.random.rand() * snr / np.sqrt(ps)
            beta[i, 0] = -xi * np.sign(np.dot(X[:, i].T, e)[0])

    y = np.dot(X, beta) - e

    return X, y, beta